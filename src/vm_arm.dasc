|// Low-level VM code for ARM CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
|
|.arch arm
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|// Note: The ragged indentation of the instructions is intentional.
|//       The starting columns indicate data dependencies.
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|
|// The following must be C callee-save.
|.define MASKR8,	r4	// 255*8 constant for fast bytecode decoding.
|.define KBASE,		r5	// Constants of current Lua function.
|.define PC,		r6	// Next PC.
|.define DISPATCH,	r7	// Opcode dispatch table.
|.define LREG,		r8	// Register holding lua_State (also in SAVE_L).
|
|// C callee-save in EABI, but often refetched. Temporary in iOS 3.0+.
|.define BASE,		r9	// Base of current Lua stack frame.
|
|// The following temporaries are not saved across C calls, except for RA/RC.
|.define RA,		r10	// Callee-save.
|.define RC,		r11	// Callee-save.
|.define RB,		r12
|.define OP,		r12	// Overlaps RB, must not be lr.
|.define INS,		lr
|
|// Calling conventions. Also used as temporaries.
|.define CARG1,		r0
|.define CARG2,		r1
|.define CARG3,		r2
|.define CARG4,		r3
|.define CARG12,	r0	// For 1st soft-fp double.
|.define CARG34,	r2	// For 2nd soft-fp double.
|
|.define CRET1,		r0
|.define CRET2,		r1
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|.define SAVE_R4,	[sp, #28]
|.define CFRAME_SPACE,	#28
|.define SAVE_ERRF,	[sp, #24]
|.define SAVE_NRES,	[sp, #20]
|.define SAVE_CFRAME,	[sp, #16]
|.define SAVE_L,	[sp, #12]
|.define SAVE_PC,	[sp, #8]
|.define SAVE_MULTRES,	[sp, #4]
|.define ARG5,		[sp]
|
|.define TMPDhi,	[sp, #4]
|.define TMPDlo,	[sp]
|.define TMPD,		[sp]
|.define TMPDp,		sp
|
|.if FPU
|.macro saveregs
|  push {r5, r6, r7, r8, r9, r10, r11, lr}
|  vpush {d8-d15}
|  sub sp, sp, CFRAME_SPACE+4
|  str r4, SAVE_R4
|.endmacro
|.macro restoreregs_ret
|  ldr r4, SAVE_R4
|  add sp, sp, CFRAME_SPACE+4
|  vpop {d8-d15}
|  pop {r5, r6, r7, r8, r9, r10, r11, pc}
|.endmacro
|.else
|.macro saveregs
|  push {r4, r5, r6, r7, r8, r9, r10, r11, lr}
|  sub sp, sp, CFRAME_SPACE
|.endmacro
|.macro restoreregs_ret
|  add sp, sp, CFRAME_SPACE
|  pop {r4, r5, r6, r7, r8, r9, r10, r11, pc}
|.endmacro
|.endif
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State,	LREG
|.type GL,		global_State
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS8,		int
|.type TRACE,		GCtrace
|.type SBUF,		SBuf
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; ud; .endmacro
|
|//-----------------------------------------------------------------------
|
|// Access to frame relative to BASE.
|.define FRAME_FUNC,	#-8
|.define FRAME_PC,	#-4
|
|.macro decode_RA8, dst, ins; and dst, MASKR8, ins, lsr #5; .endmacro
|.macro decode_RB8, dst, ins; and dst, MASKR8, ins, lsr #21; .endmacro
|.macro decode_RC8, dst, ins; and dst, MASKR8, ins, lsr #13; .endmacro
|.macro decode_RD, dst, ins; lsr dst, ins, #16; .endmacro
|.macro decode_OP, dst, ins; and dst, ins, #255; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  ldrb OP, [PC]
|.endmacro
|.macro ins_NEXT2
|   ldr INS, [PC], #4
|.endmacro
|// Instruction decode+dispatch.
|.macro ins_NEXT3
|  ldr OP, [DISPATCH, OP, lsl #2]
|   decode_RA8 RA, INS
|   decode_RD RC, INS
|  bx OP
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|  ins_NEXT3
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|  .define ins_next3, ins_NEXT3
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    b ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|  .endmacro
|  .macro ins_next3
|    b ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Avoid register name substitution for field name.
#define field_pc	pc
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  ldr PC, LFUNC:CARG3->field_pc
|  ldrb OP, [PC]  // STALL: load PC. early PC.
|   ldr INS, [PC], #4
|  ldr OP, [DISPATCH, OP, lsl #2]  // STALL: load OP. early OP.
|   decode_RA8 RA, INS
|   add RA, RA, BASE
|  bx OP
|.endmacro
|
|.macro ins_call
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  str PC, [BASE, FRAME_PC]
|  ins_callt  // STALL: locked PC.
|.endmacro
|
|//-----------------------------------------------------------------------
|
|// Macros to test operand types.
|.macro checktp, reg, tp; cmn reg, #-tp; .endmacro
|.macro checktpeq, reg, tp; cmneq reg, #-tp; .endmacro
|.macro checktpne, reg, tp; cmnne reg, #-tp; .endmacro
|.macro checkstr, reg, target; checktp reg, LJ_TSTR; bne target; .endmacro
|.macro checktab, reg, target; checktp reg, LJ_TTAB; bne target; .endmacro
|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC; bne target; .endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|.macro hotcheck, delta
|  lsr CARG1, PC, #1
|  and CARG1, CARG1, #126
|  sub CARG1, CARG1, #-GG_DISP2HOT
|  ldrh CARG2, [DISPATCH, CARG1]
|  subs CAR