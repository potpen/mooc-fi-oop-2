|// Low-level VM code for ARM CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
|
|.arch arm
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|// Note: The ragged indentation of the instructions is intentional.
|//       The starting columns indicate data dependencies.
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|
|// The following must be C callee-save.
|.define MASKR8,	r4	// 255*8 constant for fast bytecode decoding.
|.define KBASE,		r5	// Constants of current Lua function.
|.define PC,		r6	// Next PC.
|.define DISPATCH,	r7	// Opcode dispatch table.
|.define LREG,		r8	// Register holding lua_State (also in SAVE_L).
|
|// C callee-save in EABI, but often refetched. Temporary in iOS 3.0+.
|.define BASE,		r9	// Base of current Lua stack frame.
|
|// The following temporaries are not saved across C calls, except for RA/RC.
|.define RA,		r10	// Callee-save.
|.define RC,		r11	// Callee-save.
|.define RB,		r12
|.define OP,		r12	// Overlaps RB, must not be lr.
|.define INS,		lr
|
|// Calling conventions. Also used as temporaries.
|.define CARG1,		r0
|.define CARG2,		r1
|.define CARG3,		r2
|.define CARG4,		r3
|.define CARG12,	r0	// For 1st soft-fp double.
|.define CARG34,	r2	// For 2nd soft-fp double.
|
|.define CRET1,		r0
|.define CRET2,		r1
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|.define SAVE_R4,	[sp, #28]
|.define CFRAME_SPACE,	#28
|.define SAVE_ERRF,	[sp, #24]
|.define SAVE_NRES,	[sp, #20]
|.define SAVE_CFRAME,	[sp, #16]
|.define SAVE_L,	[sp, #12]
|.define SAVE_PC,	[sp, #8]
|.define SAVE_MULTRES,	[sp, #4]
|.define ARG5,		[sp]
|
|.define TMPDhi,	[sp, #4]
|.define TMPDlo,	[sp]
|.define TMPD,		[sp]
|.define TMPDp,		sp
|
|.if FPU
|.macro saveregs
|  push {r5, r6, r7, r8, r9, r10, r11, lr}
|  vpush {d8-d15}
|  sub sp, sp, CFRAME_SPACE+4
|  str r4, SAVE_R4
|.endmacro
|.macro restoreregs_ret
|  ldr r4, SAVE_R4
|  add sp, sp, CFRAME_SPACE+4
|  vpop {d8-d15}
|  pop {r5, r6, r7, r8, r9, r10, r11, pc}
|.endmacro
|.else
|.macro saveregs
|  push {r4, r5, r6, r7, r8, r9, r10, r11, lr}
|  sub sp, sp, CFRAME_SPACE
|.endmacro
|.macro restoreregs_ret
|  add sp, sp, CFRAME_SPACE
|  pop {r4, r5, r6, r7, r8, r9, r10, r11, pc}
|.endmacro
|.endif
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State,	LREG
|.type GL,		global_State
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS8,		int
|.type TRACE,		GCtrace
|.type SBUF,		SBuf
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; ud; .endmacro
|
|//-----------------------------------------------------------------------
|
|// Access to frame relative to BASE.
|.define FRAME_FUNC,	#-8
|.define FRAME_PC,	#-4
|
|.macro decode_RA8, dst, ins; and dst, MASKR8, ins, lsr #5; .endmacro
|.macro decode_RB8, dst, ins; and dst, MASKR8, ins, lsr #21; .endmacro
|.macro decode_RC8, dst, ins; and dst, MASKR8, ins, lsr #13; .endmacro
|.macro decode_RD, dst, ins; lsr dst, ins, #16; .endmacro
|.macro decode_OP, dst, ins; and dst, ins, #255; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  ldrb OP, [PC]
|.endmacro
|.macro ins_NEXT2
|   ldr INS, [PC], #4
|.endmacro
|// Instruction decode+dispatch.
|.macro ins_NEXT3
|  ldr OP, [DISPATCH, OP, lsl #2]
|   decode_RA8 RA, INS
|   decode_RD RC, INS
|  bx OP
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|  ins_NEXT3
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|  .define ins_next3, ins_NEXT3
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    b ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|  .endmacro
|  .macro ins_next3
|    b ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Avoid register name substitution for field name.
#define field_pc	pc
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  ldr PC, LFUNC:CARG3->field_pc
|  ldrb OP, [PC]  // STALL: load PC. early PC.
|   ldr INS, [PC], #4
|  ldr OP, [DISPATCH, OP, lsl #2]  // STALL: load OP. early OP.
|   decode_RA8 RA, INS
|   add RA, RA, BASE
|  bx OP
|.endmacro
|
|.macro ins_call
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  str PC, [BASE, FRAME_PC]
|  ins_callt  // STALL: locked PC.
|.endmacro
|
|//-----------------------------------------------------------------------
|
|// Macros to test operand types.
|.macro checktp, reg, tp; cmn reg, #-tp; .endmacro
|.macro checktpeq, reg, tp; cmneq reg, #-tp; .endmacro
|.macro checktpne, reg, tp; cmnne reg, #-tp; .endmacro
|.macro checkstr, reg, target; checktp reg, LJ_TSTR; bne target; .endmacro
|.macro checktab, reg, target; checktp reg, LJ_TTAB; bne target; .endmacro
|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC; bne target; .endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|.macro hotcheck, delta
|  lsr CARG1, PC, #1
|  and CARG1, CARG1, #126
|  sub CARG1, CARG1, #-GG_DISP2HOT
|  ldrh CARG2, [DISPATCH, CARG1]
|  subs CARG2, CARG2, #delta
|  strh CARG2, [DISPATCH, CARG1]
|.endmacro
|
|.macro hotloop
|  hotcheck HOTCOUNT_LOOP
|  blo ->vm_hotloop
|.endmacro
|
|.macro hotcall
|  hotcheck HOTCOUNT_CALL
|  blo ->vm_hotcall
|.endmacro
|
|// Set current VM state.
|.macro mv_vmstate, reg, st; mvn reg, #LJ_VMST_..st; .endmacro
|.macro st_vmstate, reg; str reg, [DISPATCH, #DISPATCH_GL(vmstate)]; .endmacro
|
|// Move table write barrier back. Overwrites mark and tmp.
|.macro barrierback, tab, mark, tmp
|  ldr tmp, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
|   bic mark, mark, #LJ_GC_BLACK		// black2gray(tab)
|  str tab, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
|   strb mark, tab->marked
|  str tmp, tab->gclist
|.endmacro
|
|.macro .IOS, a, b
|.if IOS
|  a, b
|.endif
|.endmacro
|
|//-----------------------------------------------------------------------

#if !LJ_DUALNUM
#error "Only dual-number mode supported for ARM target"
#endif

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_returnp:
  |  // See vm_return. Also: RB = previous base.
  |  tst PC, #FRAME_P
  |  beq ->cont_dispatch
  |
  |  // Return from pcall or xpcall fast func.
  |  ldr PC, [RB, FRAME_PC]		// Fetch PC of previous frame.
  |   mvn CARG2, #~LJ_TTRUE
  |  mov BASE, RB
  |  // Prepending may overwrite the pcall frame, so do it at the end.
  |   str CARG2, [RA, FRAME_PC]		// Prepend true to results.
  |  sub RA, RA, #8
  |
  |->vm_returnc:
  |  adds RC, RC, #8			// RC = (nresults+1)*8.
  |  mov CRET1, #LUA_YIELD
  |  beq ->vm_unwind_c_eh
  |  str RC, SAVE_MULTRES
  |  ands CARG1, PC, #FRAME_TYPE
  |  beq ->BC_RET_Z			// Handle regular return to Lua.
  |
  |->vm_return:
  |  // BASE = base, RA = resultptr, RC/MULTRES = (nresults+1)*8, PC = return
  |  // CARG1 = PC & FRAME_TYPE
  |  bic RB, PC, #FRAME_TYPEP
  |   cmp CARG1, #FRAME_C
  |  sub RB, BASE, RB			// RB = previous base.
  |   bne ->vm_returnp
  |
  |  str RB, L->base
  |   ldr KBASE, SAVE_NRES
  |    mv_vmstate CARG4, C
  |   sub BASE, BASE, #8
  |  subs CARG3, RC, #8
  |   lsl KBASE, KBASE, #3		// KBASE = (nresults_wanted+1)*8
  |    st_vmstate CARG4
  |  beq >2
  |1:
  |  subs CARG3, CARG3, #8
  |   ldrd CARG12, [RA], #8
  |   strd CARG12, [BASE], #8
  |  bne <1
  |2:
  |  cmp KBASE, RC			// More/less results wanted?
  |  bne >6
  |3:
  |  str BASE, L->top			// Store new top.
  |
  |->vm_leave_cp:
  |  ldr RC, SAVE_CFRAME		// Restore previous C frame.
  |   mov CRET1, #0			// Ok return status for vm_pcall.
  |  str RC, L->cframe
  |
  |->vm_leave_unw:
  |  restoreregs_ret
  |
  |6:
  |  blt >7				// Less results wanted?
  |  // More results wanted. Check stack size and fill up results with nil.
  |  ldr CARG3, L->maxstack
  |   mvn CARG2, #~LJ_TNIL
  |  cmp BASE, CARG3
  |  bhs >8
  |   str CARG2, [BASE, #4]
  |  add RC, RC, #8
  |  add BASE, BASE, #8
  |  b <2
  |
  |7:  // Less results wanted.
  |  sub CARG1, RC, KBASE
  |  cmp KBASE, #0			// LUA_MULTRET+1 case?
  |  subne BASE, BASE, CARG1		// Either keep top or shrink it.
  |  b <3
  |
  |8:  // Corner case: need to grow stack for filling up results.
  |  // This can happen if:
  |  // - A C function grows the stack (a lot).
  |  // - The GC shrinks the stack in between.
  |  // - A return back from a lua_call() with (high) nresults adjustment.
  |  str BASE, L->top			// Save current top held in BASE (yes).
  |  lsr CARG2, KBASE, #3
  |  mov CARG1, L
  |  bl extern lj_state_growstack	// (lua_State *L, int n)
  |  ldr BASE, L->top			// Need the (realloced) L->top in BASE.
  |  b <2
  |
  |->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  |  // (void *cframe, int errcode)
  |  mov sp, CARG1
  |  mov CRET1, CARG2
  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
  |  ldr L, SAVE_L
  |   mv_vmstate CARG4, C
  |  ldr GL:CARG3, L->glref
  |   str CARG4, GL:CARG3->vmstate
  |  b ->vm_leave_unw
  |
  |->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  |  // (void *cframe)
  |  bic CARG1, CARG1, #~CFRAME_RAWMASK	// Use two steps: bic sp is deprecated.
  |  mov sp, CARG1
  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  |  ldr L, SAVE_L
  |   mov MASKR8, #255
  |    mov RC, #16			// 2 results: false + error message.
  |   lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  |  ldr BASE, L->base
  |   ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  |    mvn CARG1, #~LJ_TFALSE
  |  sub RA, BASE, #8			// Results start at BASE-8.
  |  ldr PC, [BASE, FRAME_PC]		// Fetch PC of previous frame.
  |   add DISPATCH, DISPATCH, #GG_G2DISP
  |   mv_vmstate CARG2, INTERP
  |    str CARG1, [BASE, #-4]		// Prepend false to error message.
  |   st_vmstate CARG2
  |  b ->vm_returnc
  |
  |->vm_unwind_ext:			// Complete external unwind.
#if !LJ_NO_UNWIND
  |  push {r0, r1, r2, lr}
  |  bl extern _Unwind_Complete
  |  ldr r0, [sp]
  |  bl extern _Unwind_DeleteException
  |  pop {r0, r1, r2, lr}
  |  mov r0, r1
  |  bx r2
#endif
  |
  |//-----------------------------------------------------------------------
  |//-- Grow stack for calls -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_growstack_c:			// Grow stack for C function.
  |  // CARG1 = L
  |  mov CARG2, #LUA_MINSTACK
  |  b >2
  |
  |->vm_growstack_l:			// Grow stack for Lua function.
  |  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  |  add RC, BASE, RC
  |   sub RA, RA, BASE
  |    mov CARG1, L
  |  str BASE, L->base
  |   add PC, PC, #4			// Must point after first instruction.
  |  str RC, L->top
  |   lsr CARG2, RA, #3
  |2:
  |  // L->base = new base, L->top = top
  |  str PC, SAVE_PC
  |  bl extern lj_state_growstack	// (lua_State *L, int n)
  |  ldr BASE, L->base
  |   ldr RC, L->top
  |  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  |   sub NARGS8:RC, RC, BASE
  |  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  |  ins_callt				// Just retry the call.
  |
  |//-----------------------------------------------------------------------
  |//-- Entry points into the assembler VM ---------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_resume:				// Setup C frame and resume thread.
  |  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  |  saveregs
  |  mov L, CARG1
  |    ldr DISPATCH, L:CARG1->glref	// Setup pointer to dispatch table.
  |  mov BASE, CARG2
  |    add DISPATCH, DISPATCH, #GG_G2DISP
  |   str L, SAVE_L
  |  mov PC, #FRAME_CP
  |   str CARG3, SAVE_NRES
  |    add CARG2, sp, #CFRAME_RESUME
  |  ldrb CARG1, L->status
  |   str CARG3, SAVE_ERRF
