
|// Low-level VM code for MIPS CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
|//
|// MIPS soft-float support contributed by Djordje Kovacevic and
|// Stefan Pejic from RT-RK.com, sponsored by Cisco Systems, Inc.
|
|.arch mips
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|// Note: The ragged indentation of the instructions is intentional.
|//       The starting columns indicate data dependencies.
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|// Don't use: r0 = 0, r26/r27 = reserved, r28 = gp, r29 = sp, r31 = ra
|
|.macro .FPU, a, b
|.if FPU
|  a, b
|.endif
|.endmacro
|
|// The following must be C callee-save (but BASE is often refetched).
|.define BASE,		r16	// Base of current Lua stack frame.
|.define KBASE,		r17	// Constants of current Lua function.
|.define PC,		r18	// Next PC.
|.define DISPATCH,	r19	// Opcode dispatch table.
|.define LREG,		r20	// Register holding lua_State (also in SAVE_L).
|.define MULTRES,	r21	// Size of multi-result: (nresults+1)*8.
|
|.define JGL,		r30	// On-trace: global_State + 32768.
|
|// Constants for type-comparisons, stores and conversions. C callee-save.
|.define TISNUM,	r22
|.define TISNIL,	r30
|.if FPU
|.define TOBIT,		f30	// 2^52 + 2^51.
|.endif
|
|// The following temporaries are not saved across C calls, except for RA.
|.define RA,		r23	// Callee-save.
|.define RB,		r8
|.define RC,		r9
|.define RD,		r10
|.define INS,		r11
|
|.define AT,		r1	// Assembler temporary.
|.define TMP0,		r12
|.define TMP1,		r13
|.define TMP2,		r14
|.define TMP3,		r15
|
|// MIPS o32 calling convention.
|.define CFUNCADDR,	r25
|.define CARG1,		r4
|.define CARG2,		r5
|.define CARG3,		r6
|.define CARG4,		r7
|
|.define CRET1,		r2
|.define CRET2,		r3
|
|.if ENDIAN_LE
|.define SFRETLO,	CRET1
|.define SFRETHI,	CRET2
|.define SFARG1LO,	CARG1
|.define SFARG1HI,	CARG2
|.define SFARG2LO,	CARG3
|.define SFARG2HI,	CARG4
|.else
|.define SFRETLO,	CRET2
|.define SFRETHI,	CRET1
|.define SFARG1LO,	CARG2
|.define SFARG1HI,	CARG1
|.define SFARG2LO,	CARG4
|.define SFARG2HI,	CARG3
|.endif
|
|.if FPU
|.define FARG1,		f12
|.define FARG2,		f14
|
|.define FRET1,		f0
|.define FRET2,		f2
|.endif
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|.if FPU		// MIPS32 hard-float.
|
|.define CFRAME_SPACE,	112	// Delta for sp.
|
|.define SAVE_ERRF,	124(sp)	// 32 bit C frame info.
|.define SAVE_NRES,	120(sp)
|.define SAVE_CFRAME,	116(sp)
|.define SAVE_L,	112(sp)
|//----- 8 byte aligned, ^^^^ 16 byte register save area, owned by interpreter.
|.define SAVE_GPR_,	72	// .. 72+10*4: 32 bit GPR saves.
|.define SAVE_FPR_,	24	// .. 24+6*8: 64 bit FPR saves.
|
|.else			// MIPS32 soft-float
|
|.define CFRAME_SPACE,	64	// Delta for sp.
|
|.define SAVE_ERRF,	76(sp)	// 32 bit C frame info.
|.define SAVE_NRES,	72(sp)
|.define SAVE_CFRAME,	68(sp)
|.define SAVE_L,	64(sp)
|//----- 8 byte aligned, ^^^^ 16 byte register save area, owned by interpreter.
|.define SAVE_GPR_,	24	// .. 24+10*4: 32 bit GPR saves.
|
|.endif
|
|.define SAVE_PC,	20(sp)
|.define ARG5,		16(sp)
|.define CSAVE_4,	12(sp)
|.define CSAVE_3,	8(sp)
|.define CSAVE_2,	4(sp)
|.define CSAVE_1,	0(sp)
|//----- 8 byte aligned, ^^^^ 16 byte register save area, owned by callee.
|
|.define ARG5_OFS,	16
|.define SAVE_MULTRES,	ARG5
|
|//-----------------------------------------------------------------------
|
|.macro saveregs
|  addiu sp, sp, -CFRAME_SPACE
|  sw ra, SAVE_GPR_+9*4(sp)
|  sw r30, SAVE_GPR_+8*4(sp)
|   .FPU sdc1 f30, SAVE_FPR_+5*8(sp)
|  sw r23, SAVE_GPR_+7*4(sp)
|  sw r22, SAVE_GPR_+6*4(sp)
|   .FPU sdc1 f28, SAVE_FPR_+4*8(sp)
|  sw r21, SAVE_GPR_+5*4(sp)
|  sw r20, SAVE_GPR_+4*4(sp)
|   .FPU sdc1 f26, SAVE_FPR_+3*8(sp)
|  sw r19, SAVE_GPR_+3*4(sp)
|  sw r18, SAVE_GPR_+2*4(sp)
|   .FPU sdc1 f24, SAVE_FPR_+2*8(sp)
|  sw r17, SAVE_GPR_+1*4(sp)
|  sw r16, SAVE_GPR_+0*4(sp)
|   .FPU sdc1 f22, SAVE_FPR_+1*8(sp)
|   .FPU sdc1 f20, SAVE_FPR_+0*8(sp)
|.endmacro
|
|.macro restoreregs_ret
|  lw ra, SAVE_GPR_+9*4(sp)
|  lw r30, SAVE_GPR_+8*4(sp)
|   .FPU ldc1 f30, SAVE_FPR_+5*8(sp)
|  lw r23, SAVE_GPR_+7*4(sp)
|  lw r22, SAVE_GPR_+6*4(sp)
|   .FPU ldc1 f28, SAVE_FPR_+4*8(sp)
|  lw r21, SAVE_GPR_+5*4(sp)
|  lw r20, SAVE_GPR_+4*4(sp)
|   .FPU ldc1 f26, SAVE_FPR_+3*8(sp)
|  lw r19, SAVE_GPR_+3*4(sp)
|  lw r18, SAVE_GPR_+2*4(sp)
|   .FPU ldc1 f24, SAVE_FPR_+2*8(sp)
|  lw r17, SAVE_GPR_+1*4(sp)
|  lw r16, SAVE_GPR_+0*4(sp)
|   .FPU ldc1 f22, SAVE_FPR_+1*8(sp)
|   .FPU ldc1 f20, SAVE_FPR_+0*8(sp)
|  jr ra
|  addiu sp, sp, CFRAME_SPACE
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State,	LREG
|.type GL,		global_State
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS8,		int
|.type TRACE,		GCtrace
|.type SBUF,		SBuf
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; .long 0xec1cf0f0; .endmacro
|
|// Macros to mark delay slots.
|.macro ., a; a; .endmacro
|.macro ., a,b; a,b; .endmacro
|.macro ., a,b,c; a,b,c; .endmacro
|
|//-----------------------------------------------------------------------
|
|// Endian-specific defines.
|.if ENDIAN_LE
|.define FRAME_PC,	-4
|.define FRAME_FUNC,	-8
|.define HI,		4
|.define LO,		0
|.define OFS_RD,	2
|.define OFS_RA,	1
|.define OFS_OP,	0
|.else
|.define FRAME_PC,	-8
|.define FRAME_FUNC,	-4
|.define HI,		0
|.define LO,		4
|.define OFS_RD,	0
|.define OFS_RA,	2
|.define OFS_OP,	3
|.endif
|
|// Instruction decode.
|.macro decode_OP1, dst, ins; andi dst, ins, 0xff; .endmacro
|.macro decode_OP4a, dst, ins; andi dst, ins, 0xff; .endmacro
|.macro decode_OP4b, dst; sll dst, dst, 2; .endmacro
|.macro decode_RC4a, dst, ins; srl dst, ins, 14; .endmacro
|.macro decode_RC4b, dst; andi dst, dst, 0x3fc; .endmacro
|.macro decode_RD4b, dst; sll dst, dst, 2; .endmacro
|.macro decode_RA8a, dst, ins; srl dst, ins, 5; .endmacro
|.macro decode_RA8b, dst; andi dst, dst, 0x7f8; .endmacro
|.macro decode_RB8a, dst, ins; srl dst, ins, 21; .endmacro
|.macro decode_RB8b, dst; andi dst, dst, 0x7f8; .endmacro
|.macro decode_RD8a, dst, ins; srl dst, ins, 16; .endmacro
|.macro decode_RD8b, dst; sll dst, dst, 3; .endmacro
|.macro decode_RDtoRC8, dst, src; andi dst, src, 0x7f8; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  lw INS, 0(PC)
|   addiu PC, PC, 4
|.endmacro
|// Instruction decode+dispatch.
|.macro ins_NEXT2
|  decode_OP4a TMP1, INS
|  decode_OP4b TMP1
|  addu TMP0, DISPATCH, TMP1
|   decode_RD8a RD, INS
|  lw AT, 0(TMP0)
|   decode_RA8a RA, INS
|   decode_RD8b RD
|  jr AT
|   decode_RA8b RA
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    b ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|    b ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  lw PC, LFUNC:RB->pc
|  lw INS, 0(PC)
|   addiu PC, PC, 4
|  decode_OP4a TMP1, INS
|   decode_RA8a RA, INS
|  decode_OP4b TMP1
|   decode_RA8b RA
|  addu TMP0, DISPATCH, TMP1
|  lw TMP0, 0(TMP0)
|  jr TMP0
|   addu RA, RA, BASE
|.endmacro
|
|.macro ins_call
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  sw PC, FRAME_PC(BASE)
|  ins_callt
|.endmacro
|
|//-----------------------------------------------------------------------
|
|.macro branch_RD
|  srl TMP0, RD, 1
|  lui AT, (-(BCBIAS_J*4 >> 16) & 65535)
|  addu TMP0, TMP0, AT
|  addu PC, PC, TMP0
|.endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
#define GG_DISP2GOT		(GG_OFS(got) - GG_OFS(dispatch))
#define DISPATCH_GOT(name)	(GG_DISP2GOT + 4*LJ_GOT_##name)
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|.macro load_got, func
|  lw CFUNCADDR, DISPATCH_GOT(func)(DISPATCH)
|.endmacro
|// Much faster. Sadly, there's no easy way to force the required code layout.
|// .macro call_intern, func; bal extern func; .endmacro
|.macro call_intern, func; jalr CFUNCADDR; .endmacro
|.macro call_extern; jalr CFUNCADDR; .endmacro
|.macro jmp_extern; jr CFUNCADDR; .endmacro
|
|.macro hotcheck, delta, target
|  srl TMP1, PC, 1
|  andi TMP1, TMP1, 126
|  addu TMP1, TMP1, DISPATCH
|  lhu TMP2, GG_DISP2HOT(TMP1)
|  addiu TMP2, TMP2, -delta
|  bltz TMP2, target
|.  sh TMP2, GG_DISP2HOT(TMP1)
|.endmacro
|
|.macro hotloop
|  hotcheck HOTCOUNT_LOOP, ->vm_hotloop
|.endmacro
|
|.macro hotcall
|  hotcheck HOTCOUNT_CALL, ->vm_hotcall
|.endmacro
|
|// Set current VM state. Uses TMP0.
|.macro li_vmstate, st; li TMP0, ~LJ_VMST_..st; .endmacro
|.macro st_vmstate; sw TMP0, DISPATCH_GL(vmstate)(DISPATCH); .endmacro
|
|// Move table write barrier back. Overwrites mark and tmp.
|.macro barrierback, tab, mark, tmp, target
|  lw tmp, DISPATCH_GL(gc.grayagain)(DISPATCH)
|   andi mark, mark, ~LJ_GC_BLACK & 255		// black2gray(tab)
|  sw tab, DISPATCH_GL(gc.grayagain)(DISPATCH)
|   sb mark, tab->marked
|  b target
|.  sw tmp, tab->gclist
|.endmacro
|
|//-----------------------------------------------------------------------

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_returnp:
  |  // See vm_return. Also: TMP2 = previous base.
  |  andi AT, PC, FRAME_P
  |  beqz AT, ->cont_dispatch
  |.  li TMP1, LJ_TTRUE
  |
  |  // Return from pcall or xpcall fast func.
  |  lw PC, FRAME_PC(TMP2)		// Fetch PC of previous frame.
  |  move BASE, TMP2			// Restore caller base.
  |  // Prepending may overwrite the pcall frame, so do it at the end.
  |   sw TMP1, FRAME_PC(RA)		// Prepend true to results.
  |   addiu RA, RA, -8
  |
  |->vm_returnc:
  |   addiu RD, RD, 8			// RD = (nresults+1)*8.
  |  andi TMP0, PC, FRAME_TYPE
  |   beqz RD, ->vm_unwind_c_eh
  |.   li CRET1, LUA_YIELD
  |  beqz TMP0, ->BC_RET_Z		// Handle regular return to Lua.
  |.  move MULTRES, RD
  |
  |->vm_return:
  |  // BASE = base, RA = resultptr, RD/MULTRES = (nresults+1)*8, PC = return
  |  // TMP0 = PC & FRAME_TYPE
  |   li TMP2, -8
  |  xori AT, TMP0, FRAME_C
  |   and TMP2, PC, TMP2
  |  bnez AT, ->vm_returnp
  |.  subu TMP2, BASE, TMP2		// TMP2 = previous base.
  |
  |  addiu TMP1, RD, -8
  |   sw TMP2, L->base
  |    li_vmstate C
  |   lw TMP2, SAVE_NRES
  |   addiu BASE, BASE, -8
  |    st_vmstate
  |  beqz TMP1, >2
  |.   sll TMP2, TMP2, 3
  |1:
  |  addiu TMP1, TMP1, -8
  |   lw SFRETHI, HI(RA)
  |    lw SFRETLO, LO(RA)
  |    addiu RA, RA, 8
  |   sw SFRETHI, HI(BASE)
  |    sw SFRETLO, LO(BASE)
  |  bnez TMP1, <1
  |.  addiu BASE, BASE, 8
  |
  |2:
  |  bne TMP2, RD, >6
  |3:
  |.  sw BASE, L->top			// Store new top.
  |
  |->vm_leave_cp:
  |  lw TMP0, SAVE_CFRAME		// Restore previous C frame.
  |   move CRET1, r0			// Ok return status for vm_pcall.
  |  sw TMP0, L->cframe
  |
  |->vm_leave_unw:
  |  restoreregs_ret
  |
  |6:
  |  lw TMP1, L->maxstack
  |  slt AT, TMP2, RD
  |  bnez AT, >7			// Less results wanted?
  |  // More results wanted. Check stack size and fill up results with nil.
  |.  slt AT, BASE, TMP1
  |  beqz AT, >8
  |.  nop
  |  sw TISNIL, HI(BASE)
  |  addiu RD, RD, 8
  |  b <2
  |.  addiu BASE, BASE, 8
  |
  |7:  // Less results wanted.
  |  subu TMP0, RD, TMP2
  |  subu TMP0, BASE, TMP0		// Either keep top or shrink it.
  |  b <3
  |.  movn BASE, TMP0, TMP2		// LUA_MULTRET+1 case?
  |
  |8:  // Corner case: need to grow stack for filling up results.
  |  // This can happen if:
  |  // - A C function grows the stack (a lot).
  |  // - The GC shrinks the stack in between.
  |  // - A return back from a lua_call() with (high) nresults adjustment.
  |  load_got lj_state_growstack
  |   move MULTRES, RD
  |  srl CARG2, TMP2, 3
  |  call_intern lj_state_growstack	// (lua_State *L, int n)
  |.  move CARG1, L
  |    lw TMP2, SAVE_NRES
  |  lw BASE, L->top			// Need the (realloced) L->top in BASE.
  |   move RD, MULTRES
  |  b <2
  |.   sll TMP2, TMP2, 3
  |
  |->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  |  // (void *cframe, int errcode)
  |  move sp, CARG1
  |  move CRET1, CARG2
  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
  |  lw L, SAVE_L
  |   li TMP0, ~LJ_VMST_C
  |  lw GL:TMP1, L->glref
  |  b ->vm_leave_unw
  |.  sw TMP0, GL:TMP1->vmstate
  |
  |->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  |  // (void *cframe)
  |  li AT, -4
  |  and sp, CARG1, AT
  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  |  lw L, SAVE_L
  |     .FPU lui TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
  |     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
  |     li TISNIL, LJ_TNIL
  |  lw BASE, L->base
  |   lw DISPATCH, L->glref		// Setup pointer to dispatch table.
  |     .FPU mtc1 TMP3, TOBIT
  |  li TMP1, LJ_TFALSE
  |    li_vmstate INTERP
  |  lw PC, FRAME_PC(BASE)		// Fetch PC of previous frame.
  |     .FPU cvt.d.s TOBIT, TOBIT
  |  addiu RA, BASE, -8			// Results start at BASE-8.
  |   addiu DISPATCH, DISPATCH, GG_G2DISP
  |  sw TMP1, HI(RA)			// Prepend false to error message.
  |    st_vmstate
  |  b ->vm_returnc
  |.  li RD, 16				// 2 results: false + error message.
  |
  |->vm_unwind_stub:			// Jump to exit stub from unwinder.
  |  jr CARG1
  |.  move ra, CARG2
  |
  |//-----------------------------------------------------------------------
  |//-- Grow stack for calls -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_growstack_c:			// Grow stack for C function.
  |  b >2
  |.  li CARG2, LUA_MINSTACK
  |
  |->vm_growstack_l:			// Grow stack for Lua function.
  |  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  |  addu RC, BASE, RC
  |   subu RA, RA, BASE
  |  sw BASE, L->base
  |   addiu PC, PC, 4			// Must point after first instruction.
  |  sw RC, L->top
  |   srl CARG2, RA, 3
  |2:
  |  // L->base = new base, L->top = top
  |  load_got lj_state_growstack
  |   sw PC, SAVE_PC
  |  call_intern lj_state_growstack	// (lua_State *L, int n)
  |.  move CARG1, L
  |  lw BASE, L->base
  |  lw RC, L->top
  |  lw LFUNC:RB, FRAME_FUNC(BASE)
  |  subu RC, RC, BASE
  |  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  |  ins_callt				// Just retry the call.
  |
  |//-----------------------------------------------------------------------
  |//-- Entry points into the assembler VM ---------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_resume:				// Setup C frame and resume thread.
  |  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  |  saveregs
  |  move L, CARG1
  |    lw DISPATCH, L->glref		// Setup pointer to dispatch table.
  |  move BASE, CARG2
  |    lbu TMP1, L->status
  |   sw L, SAVE_L
  |  li PC, FRAME_CP
  |  addiu TMP0, sp, CFRAME_RESUME
  |    addiu DISPATCH, DISPATCH, GG_G2DISP
  |   sw r0, SAVE_NRES
  |   sw r0, SAVE_ERRF
  |   sw CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  |   sw r0, SAVE_CFRAME
  |    beqz TMP1, >3
  |. sw TMP0, L->cframe
  |
  |  // Resume after yield (like a return).
  |  sw L, DISPATCH_GL(cur_L)(DISPATCH)
  |  move RA, BASE
  |   lw BASE, L->base
  |     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
  |   lw TMP1, L->top
  |  lw PC, FRAME_PC(BASE)
  |     .FPU  lui TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
  |   subu RD, TMP1, BASE
  |     .FPU  mtc1 TMP3, TOBIT
  |    sb r0, L->status
  |     .FPU  cvt.d.s TOBIT, TOBIT
  |    li_vmstate INTERP
  |   addiu RD, RD, 8
  |    st_vmstate
  |   move MULTRES, RD
  |  andi TMP0, PC, FRAME_TYPE
  |  beqz TMP0, ->BC_RET_Z
  |.    li TISNIL, LJ_TNIL
  |  b ->vm_return
  |.  nop
  |
  |->vm_pcall:				// Setup protected C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  |  saveregs
  |  sw CARG4, SAVE_ERRF
  |  b >1
  |.  li PC, FRAME_CP
  |
  |->vm_call:				// Setup C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1)
  |  saveregs
  |  li PC, FRAME_C
  |
  |1:  // Entry point for vm_pcall above (PC = ftype).
  |  lw TMP1, L:CARG1->cframe
  |    move L, CARG1
  |   sw CARG3, SAVE_NRES
  |    lw DISPATCH, L->glref		// Setup pointer to dispatch table.
  |   sw CARG1, SAVE_L
  |     move BASE, CARG2
  |    addiu DISPATCH, DISPATCH, GG_G2DISP
  |   sw CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  |  sw TMP1, SAVE_CFRAME
  |  sw sp, L->cframe			// Add our C frame to cframe chain.
  |
  |3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  |  sw L, DISPATCH_GL(cur_L)(DISPATCH)
  |  lw TMP2, L->base			// TMP2 = old base (used in vmeta_call).
  |     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
  |     .FPU lui TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
  |   lw TMP1, L->top
  |     .FPU mtc1 TMP3, TOBIT
  |  addu PC, PC, BASE
  |   subu NARGS8:RC, TMP1, BASE
  |  subu PC, PC, TMP2			// PC = frame delta + frame type
  |     .FPU cvt.d.s TOBIT, TOBIT
  |    li_vmstate INTERP
  |     li TISNIL, LJ_TNIL
  |    st_vmstate
  |
  |->vm_call_dispatch:
  |  // TMP2 = old base, BASE = new base, RC = nargs*8, PC = caller PC
  |  lw TMP0, FRAME_PC(BASE)
  |  li AT, LJ_TFUNC
  |  bne TMP0, AT, ->vmeta_call
  |.  lw LFUNC:RB, FRAME_FUNC(BASE)
  |
  |->vm_call_dispatch_f:
  |  ins_call
  |  // BASE = new base, RB = func, RC = nargs*8, PC = caller PC
  |
  |->vm_cpcall:				// Setup protected C frame, call C.
  |  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  |  saveregs
  |  move L, CARG1
  |   lw TMP0, L:CARG1->stack
  |  sw CARG1, SAVE_L
  |   lw TMP1, L->top
  |     lw DISPATCH, L->glref		// Setup pointer to dispatch table.
  |  sw CARG1, SAVE_PC			// Any value outside of bytecode is ok.
  |   subu TMP0, TMP0, TMP1		// Compute -savestack(L, L->top).
  |    lw TMP1, L->cframe
  |     addiu DISPATCH, DISPATCH, GG_G2DISP
  |   sw TMP0, SAVE_NRES		// Neg. delta means cframe w/o frame.
  |  sw r0, SAVE_ERRF			// No error function.
  |    sw TMP1, SAVE_CFRAME
  |    sw sp, L->cframe			// Add our C frame to cframe chain.
  |     sw L, DISPATCH_GL(cur_L)(DISPATCH)
  |  jalr CARG4			// (lua_State *L, lua_CFunction func, void *ud)
  |.  move CFUNCADDR, CARG4
  |  move BASE, CRET1
  |  bnez CRET1, <3			// Else continue with the call.
  |.  li PC, FRAME_CP
  |  b ->vm_leave_cp			// No base? Just remove C frame.
  |.  nop
  |
  |//-----------------------------------------------------------------------
  |//-- Metamethod handling ------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// The lj_meta_* functions (except for lj_meta_cat) don't reallocate the
  |// stack, so BASE doesn't need to be reloaded across these calls.
  |
  |//-- Continuation dispatch ----------------------------------------------
  |
  |->cont_dispatch:
  |  // BASE = meta base, RA = resultptr, RD = (nresults+1)*8
  |  lw TMP0, -16+LO(BASE)		// Continuation.
  |   move RB, BASE
  |   move BASE, TMP2			// Restore caller BASE.
  |    lw LFUNC:TMP1, FRAME_FUNC(TMP2)
  |.if FFI
  |  sltiu AT, TMP0, 2
  |.endif
  |     lw PC, -16+HI(RB)		// Restore PC from [cont|PC].
  |   addu TMP2, RA, RD
  |.if FFI
  |  bnez AT, >1
  |.endif
  |.  sw TISNIL, -8+HI(TMP2)		// Ensure one valid arg.
  |    lw TMP1, LFUNC:TMP1->pc
  |  // BASE = base, RA = resultptr, RB = meta base
  |  jr TMP0				// Jump to continuation.
  |.  lw KBASE, PC2PROTO(k)(TMP1)
  |
  |.if FFI
  |1:
  |  bnez TMP0, ->cont_ffi_callback	// cont = 1: return from FFI callback.
  |  // cont = 0: tailcall from C function.
  |.  addiu TMP1, RB, -16
  |  b ->vm_call_tail
  |.  subu RC, TMP1, BASE
  |.endif
  |
  |->cont_cat:				// RA = resultptr, RB = meta base
  |  lw INS, -4(PC)
  |   addiu CARG2, RB, -16
  |  lw SFRETHI, HI(RA)
  |    lw SFRETLO, LO(RA)
  |  decode_RB8a MULTRES, INS
  |   decode_RA8a RA, INS
  |  decode_RB8b MULTRES
  |   decode_RA8b RA
  |  addu TMP1, BASE, MULTRES
  |   sw BASE, L->base
  |   subu CARG3, CARG2, TMP1
  |  sw SFRETHI, HI(CARG2)
  |  bne TMP1, CARG2, ->BC_CAT_Z
  |.  sw SFRETLO, LO(CARG2)
  |  addu RA, BASE, RA
  |  sw SFRETHI, HI(RA)
  |  b ->cont_nop
  |.  sw SFRETLO, LO(RA)
  |
  |//-- Table indexing metamethods -----------------------------------------
  |
  |->vmeta_tgets1:
  |  addiu CARG3, DISPATCH, DISPATCH_GL(tmptv)
  |  li TMP0, LJ_TSTR
  |  sw STR:RC, LO(CARG3)
  |  b >1
  |.  sw TMP0, HI(CARG3)
  |
  |->vmeta_tgets:
  |  addiu CARG2, DISPATCH, DISPATCH_GL(tmptv)
  |  li TMP0, LJ_TTAB
  |  sw TAB:RB, LO(CARG2)
  |   addiu CARG3, DISPATCH, DISPATCH_GL(tmptv2)
  |  sw TMP0, HI(CARG2)
  |   li TMP1, LJ_TSTR
  |   sw STR:RC, LO(CARG3)
  |  b >1
  |.  sw TMP1, HI(CARG3)